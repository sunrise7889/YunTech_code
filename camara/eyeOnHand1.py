import cv2
import numpy as np
from math import *
import math

''' 
robot_pose = [
             [302.806, 159.445, 562.756, 58.769, -30.564, 154.194],
             [360.342, 128.939, 526.941, 48.976, -25.417, 157.244],
             [319.817, 97.902, 598.364, 50.196, -36.242, 150.359],
             [314.539, 113.032, 589.922, 40.388, -40.901, 166.307],
             [291.997, 55.622, 559.306, 30.057, -36.282, 168.459],
             [203.666, 82.649, 608.265, 56.911, -30.051, 147.553],
             [216.951, 117.09, 587.022, 61.018, -24.754, 150.625],
             [270.996, 94.643, 568.59, 48.181, -42.452, 156.617],
             [331.652, 60.555, 499.392, 9.248, -34.409, -170.107],
             [230.921, 11.354, 572.449, 2.102, -47.116, -170.617],
             #[222.135, 55.62, 514.482, 2.293, -35.866, -158.854],
             #[144.546, 49.938, 559.657, -2.869, -54.213, -151.718],
             [236.045, 12.0, 495.868, -18.481, -26.074, -147.444],
             [154.272, 6.503, 539.783, -17.714, -47.895, -152.807],
             [153.867, -14.427, 517.915, -18.41, -40.497, -159.02],
             [112.569, 9.32, 571.749, 24.428, -35.462, 168.121],
             #[122.386, 54.985, 589.155, 22.012, -39.35, -168.092],
             [324.952, -59.004, 591.184, -22.489, -21.426, -135.483],
             #[105.07, 25.321, 724.27, 29.38, -32.067, 174.035],
             #[134.299, 21.48, 740.152, 32.902, -47.461, 161.796]
            ]
rot_vector = np.array([
[-0.59160314,0.00508004,0.63716506],
[-0.48562227,-0.06531922,0.50991979],
[-0.70829569,-0.05007936,0.44792038],
[-0.65063927,0.17639707,0.36829325],
[-0.56993849,0.10370415,0.22096867],
[-0.64652156,-0.10399088,0.57360919],
[-0.5470952 ,-0.09565537,0.68283443],
[-0.73765349,0.10742359,0.43408049],
[-0.4691951 ,0.35317203,-0.00684636],
[-0.72037204,0.33771581,-0.09864945],
#[-0.47619415,0.51807508,-0.05679537],
#[-0.79760285,0.62387432,0.00124246],
[-0.39690511,0.62082304,-0.39061872],
[-0.77073475,0.49640544,-0.2801253 ],
[-0.65098156,0.39605529,-0.37833163],
[-0.55608164,0.07014084,0.12440718],
#[-0.48769348,0.48089992,0.21856753],
[-0.34797611,0.82070671,-0.4404359 ],
#[-0.45743075,0.21478019,0.24102792],
#[-0.7875402 ,0.17213658,0.21648986]
                        ]).reshape(-1, 3)
trans = np.array([
[  4.81445389,-98.67346453,492.02551058],
[ -83.03850278,-134.85319265,410.22146384],
[-138.14709628, -37.84852193,511.29682051],
[-42.27483985,-25.65163146,532.08573197],
[-148.87411633,-93.55778477,508.64454549],
[ -87.43388401,-165.76529255,583.0373478 ],
[  -3.95702426,-201.20052903,544.48165768],
[-61.36490539,-47.50397173,546.9653751 ],
[-114.42933252,-63.62744425,465.83532191],
[-141.41108286, 41.23184855, 600.92744631],
#[ -48.53279721,-128.92242314, 551.34746206],
#[ 74.82221646, 2.23439822,665.31037027],
[-124.5292773 , -53.42091809, 553.84717558],
[-105.49120166, 56.40039471, 648.69105383],
[-219.22944766, 22.44379861, 607.45227072],
[-207.42903441,-222.24242118,604.00560218],
#[  74.7595145 ,-221.67045166,638.83842993],
[ 13.21131626, 47.20854044,625.28535422],
#[ -47.03862182,-223.28990446, 735.94199662],
#[-106.21541032, 35.86786093, 765.70934195]
                        ]).reshape(-1, 3)
'''
 
#示教器 X Y Z A B C
robot_pose = [
            [181.421,92.527,567.709,11.417,-51.817,-163.519],
            [271.817,97.532,554.531,-7.573,-51.917,-152.541],
            [226.997,54.016,510.065,-15.143,-37.364,-151.48],
            [163.909,26.81,609.118,5.174,-53.268,-175.511],
            #[159.482,10.533,655.073,-1.219,-41.113,-173.56],
            [304.966,94.506,575.379,48.807,-36.194,143.576],
            [326.004,137.705,548.732,21.488,-48.533,-178.543],
            [392.715,112.565,510.135,25.312,-38.218,170.151],
            [326.992,29.959,633.664,0.367,-41.05,-173.101],
            [249.561,103.671,683.59,20.077,-29.5,-173.605],
            [227.735,-45.69,718.651,-25.019,-35.281,-147.914],
            [151.727,-26.352,673.928,-44.063,-32.824,-130.595],
            #[134.036,26.327,620.428,28.372,-37.909,161.332],
            [397.231,133.816,539.869,21.882,-29.958,175.539],
            [310.063,-23.252,534.079,-31.112,-32.518,-150.922],
            [124.976,34.267,683.709,45.07,-57.556,147.884],
            [155.494,67.894,754.413,26.223,-41.333,173.369],
            [309.737,104.934,560.837,-7.526,-39.961,-151.236],
            [390.446,28.377,468.647,-29.94,-18.098,-145.428],
            [162.694,80.451,591.75,52.033,-58.993,152.981]
            ]
rot_vector = np.array([
[-0.85890921, 0.37210349, 0.31487934],
[-0.89664345, 0.39247242, 0.09901934],
[-0.67111282, 0.40098258,-0.08726769],
[-0.91005989, 0.12143934, 0.11604836],
#[-0.7011366 , 0.09325475, 0.01183164],
[-0.81166889,-0.30200546, 0.59613116],
[-0.81591242, 0.19676518, 0.36671053],
[-0.67057644,-0.01104245, 0.3703417 ],
[-0.70507797, 0.11998105, 0.04282058],
[-0.45966575, 0.22134375, 0.36247339],
[-0.68021312, 0.40308188,-0.25499777],
[-0.79137212, 0.57956766,-0.47184545],
#[-0.87118366,-0.09115713, 0.3195977 ],
[-0.50259681, 0.02839534, 0.35220528],
[-0.65356346, 0.32191234,-0.37740225],
[-1.0862651 ,-0.07366336, 0.41222282],
[-0.71339712, 0.06921697, 0.38080353],
[-0.69585103, 0.44780682, 0.05212994],
[-0.42825979, 0.49973044,-0.41062764],
[-1.09132577, 0.07136259, 0.57021959]
                        ]).reshape(-1, 3)
trans = np.array([
[ 87.58721517,-39.55929447,682.92751958],
[ 11.59523224, 51.28445308,616.65465318],
[-93.51001542,-95.54453962,611.90465068],
[-166.74451432, 4.78918334, 718.17132775],
#[-221.33701474, -84.5268532 , 716.8940074 ],
[-162.08217568,-121.23833279, 530.51026158],
[  4.57414763, -5.6119359 ,554.37534204],
[-104.1907107 , -88.03225968, 453.09214834],
[-195.95732227,  17.09746586, 599.51100779],
[  40.37082687,-179.93352493, 659.6467472 ],
[-126.33804258, 100.43509502, 774.68753372],
[-34.68437819,156.8751275 ,797.55818014],
#[-202.31983292,-105.98414143, 713.50827205],
[ -71.1711442 ,-122.08552856, 456.21848031],
[-242.81874039,  74.04470995, 557.40801126],
[-207.12826069,  85.2754533 , 772.42708712],
[-61.34875672,-74.22043306,809.98078854],
[ 21.33989524,-23.43043152,582.5421853 ],
[-164.65509255,   3.69881059, 474.66813141],
[-15.51704896, 70.30014608,724.25021303]
                        ]).reshape(-1, 3)


# 用于根据欧拉角计算旋转矩阵
def myRPY2R_robot(x, y, z):
    Rx = np.array([[1, 0, 0], [0, cos(x), -sin(x)], [0, sin(x), cos(x)]])
    Ry = np.array([[cos(y), 0, sin(y)], [0, 1, 0], [-sin(y), 0, cos(y)]])
    Rz = np.array([[cos(z), -sin(z), 0], [sin(z), cos(z), 0], [0, 0, 1]])
    R = np.dot(np.dot(Rz, Ry), Rx)
    return R
 
 
# 用于根据位姿计算变换矩阵
def pose_robot(z, y, x, Tx, Ty, Tz):  # 注意输入顺序！！！！！！
    """
    Args:
        x: x轴旋转角度
        y: y轴旋转角度
        z: z轴旋转角度
        Tx: Tx为平移横坐标
        Ty: Ty为平移纵坐标
        Tz: Tz为平移高坐标
    Returns: 旋转矩阵与平移矩阵的叠加，即两坐标系之间的转换矩阵
    """
    thetaX = x / 180 * pi
    thetaY = y / 180 * pi
    thetaZ = z / 180 * pi
    R = myRPY2R_robot(thetaX, thetaY, thetaZ)
    t = np.array([[Tx], [Ty], [Tz]])
    RT1 = np.column_stack([R, t])  # 列合并
    RT1 = np.row_stack((RT1, np.array([0, 0, 0, 1])))
    return RT1
 
 
# 用来从棋盘格图片得到相机外参
def get_RT_from_chessboard(rot_vector, trans):
    rotMat = cv2.Rodrigues(rot_vector)[0]
    t = np.array([[trans[0], trans[1], trans[2]]]).T
    RT = np.column_stack((rotMat, t))
    RT = np.row_stack((RT, np.array([0, 0, 0, 1])))
    return RT
 
 
def isRotationMatrix(R):
    Rt = np.transpose(R)
    shouldBeIdentity = np.dot(Rt, R)
    I = np.identity(3, dtype=R.dtype)
    n = np.linalg.norm(I - shouldBeIdentity)
    return n < 1e-6
 
 
def rotationMatrixToEulerAngles(R):
    assert (isRotationMatrix(R))
 
    sy = math.sqrt(R[0, 0] * R[0, 0] + R[1, 0] * R[1, 0])
 
    singular = sy < 1e-6
 
    if not singular:
        x = math.atan2(R[2, 1], R[2, 2])
        y = math.atan2(-R[2, 0], sy)
        z = math.atan2(R[1, 0], R[0, 0])
    else:
        x = math.atan2(-R[1, 2], R[1, 1])
        y = math.atan2(-R[2, 0], sy)
        z = 0
 
    return np.array([x, y, z])
 
 
good_picture = [i for i in range(18)]
 
# 计算标定板到相机的变换矩阵
R_all_chess_to_cam_1 = []
T_all_chess_to_cam_1 = []
for i in good_picture:
    chess2cam_RT = get_RT_from_chessboard(rot_vector[i].T, trans[i].T)
 
    R_all_chess_to_cam_1.append(chess2cam_RT[:3, :3])  # 旋转矩阵
    T_all_chess_to_cam_1.append(chess2cam_RT[:3, 3].reshape((3, 1)))  # 平移向量
 
# 计算法兰末端位姿与相机的变换矩阵
R_all_end_to_base_1 = []
T_all_end_to_base_1 = []
# print(sheet_1.iloc[0]['ax'])
for i in good_picture:
 
    end2robot_RT = pose_robot(robot_pose[i][3], robot_pose[i][4], robot_pose[i][5],
                              robot_pose[i][0], robot_pose[i][1], robot_pose[i][2])
 
    R_all_end_to_base_1.append(end2robot_RT[:3, :3])
    T_all_end_to_base_1.append(end2robot_RT[:3, 3].reshape((3, 1)))
 
# 手眼标定
R, T = cv2.calibrateHandEye(R_all_end_to_base_1, T_all_end_to_base_1, R_all_chess_to_cam_1, T_all_chess_to_cam_1)
RT = np.column_stack((R, T))
RT = np.row_stack((RT, np.array([0, 0, 0, 1])))  # 即相机到机械臂末端法兰变换矩阵
# RT = np.linalg.inv(RT)
print('相机相对于末端的变换矩阵为：')
print(RT)

chess2base_T = []
chess2base_theta = []
 
# 固定的棋盘格相对于机器人基坐标系位姿不变，对结果验证，原则上来说，每次结果相差较小
for i in range(len(good_picture)):
    RT_end_to_base = np.column_stack((R_all_end_to_base_1[i], T_all_end_to_base_1[i]))
    RT_end_to_base = np.row_stack((RT_end_to_base, np.array([0, 0, 0, 1])))
 
    RT_chess_to_cam = np.column_stack((R_all_chess_to_cam_1[i], T_all_chess_to_cam_1[i]))
    RT_chess_to_cam = np.row_stack((RT_chess_to_cam, np.array([0, 0, 0, 1])))
 
    RT_cam_to_end = np.column_stack((R, T))
    RT_cam_to_end = np.row_stack((RT_cam_to_end, np.array([0, 0, 0, 1])))
 
    RT_chess_to_base = RT_end_to_base @ RT_cam_to_end @ RT_chess_to_cam  # 即为固定的棋盘格相对于机器人基坐标系位姿不变
    RT_chess_to_base = np.linalg.inv(RT_chess_to_base)
 
    chess2base_T.append(RT_chess_to_base[:, -1])
    chess2base_theta.append(RT_chess_to_base[:3, :3])

# 棋盘格相对于机械臂基座标XYZ不变，对结果验证
for i in range(len(chess2base_T)):
    print('第', i, '次')
    print(rotationMatrixToEulerAngles(chess2base_theta[i]) / np.pi * 180)
    print(chess2base_T[i])
    print('')
